package model.adventurers;

import java.util.ArrayList;

import model.game.Coords;
import model.game.Island;
import model.game.Tile;
import model.game.TileState;
import model.player.Inventory;
import model.player.Player;
<<<<<<< HEAD
import util.exception.InadequateUseOfCapacity;
=======
import util.exception.MoveException;
>>>>>>> feature/controller



/**
 * Can be
 * a {@link Diver}<br>
 * an {@link Engineer}<br>
 * an {@link Explorater}<br>
 * a {@link Messenger}<br>
 * a {@link Navigator}<br>
 * a {@link Pilot}
 * 
 * @author nihil
 *
 */
public abstract class Adventurer {
    private static final int MAX_ACTION_POINTS = 3;
<<<<<<< HEAD
=======
    private AdventurerType   ADVENTURER_TYPE;
>>>>>>> feature/controller
    private Player           player;
    private Inventory        inventory;
    private Tile             currentTile;
    private int              actionPoints;
    
    
    public Adventurer(Player player) {
        setActionPoints(MAX_ACTION_POINTS);
        setPlayer(player);
        setInventory(new Inventory());
    }
    
    
    /**
     * 
     * 
     *
     * @param tile
     * @return true if the move done
     * @throws MoveException
     */
    public void move(Tile tile) throws MoveException {
        if (getActionPoints() >= 1 && getReachableTiles().contains(tile)) {
            setCurrentTile(tile);
            setActionPoints(getActionPoints() - 1);
            System.err.println("le deplacement a été effectué");
        } else {
<<<<<<< HEAD
            System.err.println(getActionPoints() <= 0 ? "not enough action point" : "tile note reachable");
=======
            if (getActionPoints() <= 0) {
                throw new MoveException(tile);
            } else {
                throw new MoveException(getActionPoints());
            } // end if
>>>>>>> feature/controller
        }
        
    }
    
    
    public ArrayList<Tile> getReachableTiles() {
        
        ArrayList<Tile> reachable = new ArrayList<>();
        Coords coords = getCurrentTile().getCoords();
        
<<<<<<< HEAD
        Island island = getPlayer().getCurrentGame().getIsland();
        Tile tileTmp;
        // we will apply a sweet function to get through -1,0,1,0 and meanwhile 0,1,0,-1 (uses of modulo is awesome)
        int j = 2;
        int effI;
        int effJ;
        for (int i = -1; i <= 2; i += 1) {
            effI = i % 2;
            effJ = j % 2;
            System.out.println(effI + "," + effJ);
            tileTmp = island.getTile(coords.getX() + effI, coords.getY() + effJ);
            if ((tileTmp != null) && (tileTmp.getState() != TileState.SINKED)) {
                reachable.add(tileTmp);
            }
            j--;
        } // end for
=======
        Tile[][] grid = getPlayer().getCurrentGame().getIsland().getGrid();
        
        for (int i = -1; i <= 1; i += 2) {
            Tile tileTmp = (grid[coords.getX()][coords.getY() + i]);
            if ((tileTmp != null) && (tileTmp.getState() != TileState.SINKED)) {
                reachable.add(tileTmp);
            }
            tileTmp = (grid[coords.getX() + i][coords.getY()]);
            if ((tileTmp != null) && (tileTmp.getState() != TileState.SINKED)) {
                reachable.add(tileTmp);
            }
        }
        
>>>>>>> feature/controller
        return reachable;
        
    }
    
    
    /**
<<<<<<< HEAD
     * @author nihil
     *
     * @param tile
     * @throws InadequateUseOfCapacity
     */
    public void useCapacity(Object o) throws InadequateUseOfCapacity {
        throw new InadequateUseOfCapacity();
    }// end useCapacity
    
    
    /**
     * @author nihil
     *
     * @return the objects where a capacity can be applied
     * @throws InadequateUseOfCapacity
     */
    public ArrayList<Object> getPotentialUse() throws InadequateUseOfCapacity {
        throw new InadequateUseOfCapacity();
    }
    
    
    /**
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return getClass().getSimpleName();
    }
    
    
    /**
=======
>>>>>>> feature/controller
     * @return the player
     */
    public Player getPlayer() {
        return player;
    }
    
    
    /**
     * @param player
     * the player to set
     */
    private void setPlayer(Player player) {
        this.player = player;
    }
    
    
    /**
     * @return the inventory
     */
    public Inventory getInventory() {
        return inventory;
    }
    
    
    /**
     * @param inventory
     * the inventory to set
     */
    private void setInventory(Inventory inventory) {
        this.inventory = inventory;
    }
    
    
    /**
     * @return the currentTile
     */
    public Tile getCurrentTile() {
        return currentTile;
    }
    
    
    /**
     * @param currentTile
     * the currentTile to set
     */
    protected void setCurrentTile(Tile currentTile) {
        this.currentTile = currentTile;
    }
    
    
    /**
     * @return the MAX_ACTION_POINTS
     */
    public int getMAX_ACTION_POINTS() {
        return MAX_ACTION_POINTS;
    }
    
    
    /**
     * @return the actionPoints
     */
    public int getActionPoints() {
        return actionPoints;
    }
    
    
    /**
     * @param actionPoints
     * the actionPoints to set
     */
    protected void setActionPoints(int actionPoints) {
        this.actionPoints = actionPoints;
    }
    
    
    /**
     * @return the adventurerType
     */
    public AdventurerType getADVENTURER_TYPE() {
        return ADVENTURER_TYPE;
    }
}